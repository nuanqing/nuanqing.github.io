---
title: MVC与MVVM的理解
date: 2016-04-24 23:31:30
description: 其实iOS的MVC感觉并不是经典的MVC模式，查阅很多的资料，经典的MVC是对于Web端来提出的，模型，视图，控制器之间都是单向传递数据引用，控制器只是负责业务逻辑
categories:
- 基础知识点
tags:
- MVC&MVVM
---


## MVC

其实iOS的**MVC**感觉并不是经典的**MVC**模式，查阅很多的资料，经典的**MVC**是对于**Web**端来提出的，模型，视图，控制器之间都是单向传递数据引用，控制器只是负责业务逻辑。

而iOS中控制器本身也能够创建视图，同时视图必须添加到控制器中，`UITableview`就是很好的例子，这样控制器就不单单是业务逻辑的处理，它与`View`就像连体的兄弟，同穿一条裤子一样……

更像是**MVP**这样的模式，`View`与`Presenter`紧密相连… `View` 与 `Model` 不发生联系，都通过 `Presenter` 传递。`View` 非常薄，不部署任何业务逻辑，称为"被动视图"（**Passive View**），即没有任何主动性，而 `Presenter`非常厚，所有逻辑都部署在那里
…

直到看了一篇博文，引用了斯坦福大学公开课程中的一张图:

![png1](/assets/images/mvcmvvm1.jpg)

恍然大悟，这才是真正的iOS **MVC** 的正确理解(毕竟在xcode中是Controller)

大致的意思是
`Controller`可以和`Model`通信，也可以和`View`进行通信。而`Controller`和`Model`的关系，绿色的箭头代表`Controller`可以直接进行对`Model`进行访问，也就是说`Model`对于`Controller`来说就是透明的。如果`Model`发生了变化，那么就通过`Notification`和**KVO**的方式传递给`Controller`。同样的`Controller`和`View`之间也是这种关系，`View`对`Controller`来说就是 透明的。`Controller`可以直接根据`Model`决定`View`的展示。`View`如果接受响应事件则通过**delegate**，**target-action**，**block**等方式告诉`Controller`的状态变化。`Controller`进行业务的处理，然后再控制View的控制器中展示。

简单的说， 控制器不仅需要处理业务逻辑，视图的处理也在控制器中，同时还与数据模型交互 ，显然这样的处理方式会导致控制器臃肿，耦合度高，模块不易复用，同时代码的可读性降低，这样并不好，于是iOS的**MVVM**就诞生了

## MVVM

![png1](/assets/images/mvcmvvm2.jpg)

与经典的**MVVM**也不相同，经典的**MVVM**是没有控制器的概念，只是数据的流向发生了改变， 它采用的是双向绑定，**View**的变动自动反映在**VM**(**VM**将指**ViewModel**)，反之亦然。

而iOS的**MVVM**中还有一个控制器，所以这样就是iOS特色**MVVM**

**VM**处理业务逻辑，**Model**与**VM**交互，**VM**与控制器交互，控制器与视图可以紧密相连。这样的写法可以看到，逻辑更加清晰，耦合度降低，模块复用性提高，编写测试也方便，控制器也进行了极大的减负，很棒！

但是缺点也是明显，每个控制器都需要**VM**，控制器与**Model**的交互变为控制器与**VM**交互，**VM**与**Model**的交互，代码量会增加，逻辑性需要更加的严谨，写起来也会慢一些，调试的话也会增加bug查找的难度

因为模块独立，所以两种设计模式(不是框架结构，架构是一个整体，涵盖项目方方面面)可以独立来写，控制器之间交互性低的地方，**VM**处理逻辑写法会简单些，可以考虑用**MVVM**，模块较为复杂控制器之间交互性强的地方，真的需要慢慢写了(之前想改个项目，主控制器逻辑太复杂，耦合性太高，不好剥离，最终只是写了请求部分逻辑剥离)

## 一点RAC与MVVM的理解

关于RAC
>**ReactiveCocoa**(简称**RAC**),是GitHub上开源的一个应用于iOS和OS X开发的一个新框架.**RAC**具有函数式编程和响应者编程的特性.

一个完整**RAC**“流”的实现包括：创建信号，订阅信号，发送信号

**RAC**与**MVVM**配合能够减少代码，降低耦合性，以登录界面为例，按钮的状态通过**RAC**的观察者模式监听，能够放在**VM**中，数据的请求与处理可以放在**VM**中，这些业务逻辑都可以放在**VM**中。

而单纯的**MVVM**按钮的状态改变需要通过`textfield`代理监听传给**VM**处理，然后事件再回调判断，写法上比**RAC**复杂，而且数据请求中需要给控制器接口，**RAC**只需要控制器引用**VM**的`raccommand`信号类，**RAC**的`raccommand`本身拥有回调方法。

**RAC**很棒，但是**RAC**如果写的有问题，BUG将更加难以调试，所以要掌握很多的使用方法还需要不断地学习与实践，[这里](https://github.com/nuanqing/RACBaseGrammer)有整理好的一点关于**RAC**的使用，同时加上代码的注释，如果有需要，可以看一下
